//{
    // void midAddMeasurement()
    // {
    //     if(!is_adding_measurement_) throw;
    //     if(stack_index_ != total_length_) throw;

    //     is_adding_measurement_ = false;
    //     std::cout << "midwancheng" << std::endl;
    //     Zsig_stack_.resize(total_length_, S);
    //     //GenerateSigmaPoints(x_, P_, ext_sig);
    //     ext_sig = Xsig_prediction;
    // }

    // void endAddMeasurement(typename TModel::FilterVector& state, typename TModel::FilterMatrix& state_covariance, double& time)
    // {
    //     int K = total_length_;
    //     VectorXd expected_measurement_mean = VectorXd::Zero(K);
    //     for (int i = 0; i < S; i++)
    //     {
    //         expected_measurement_mean += weights[i] * Zsig_stack_.col(i);
    //     }
    //     std::cout << "fineend" <<std::endl;
    //     MatrixXd expected_measurement_cov = MatrixXd::Zero(K, K);
    //     for (int i = 0; i < S; i++) 
    //     {
    //         VectorXd diff = Zsig_stack_.col(i) - expected_measurement_mean;
    //         expected_measurement_cov += weights[i] * diff * diff.transpose();
    //     }
    //     expected_measurement_cov += measurement_covariance_stack_;//S
    //         // calculated transformed covariance
    //     MatrixXd sigma = MatrixXd::Zero(N, K);
    //     for (int i = 0; i < ext_sig.rows(); i++) 
    //     {
    //         auto diffA = (Xsig_prediction.col(i) - x_);
    //         auto diffB = (Zsig_stack_.col(i) - expected_measurement_mean);
    //         sigma += weights[i] * (diffA * diffB.transpose());
    //     }
    //     kalman_gain = sigma * expected_measurement_cov.inverse();

    //     x_ = x_ + kalman_gain * (measurement_stack_ - expected_measurement_mean);
    //     P_ = P_ - kalman_gain * expected_measurement_cov * kalman_gain.transpose();

    //     ensurePositiveFinite(P_);

    //     state = x_;
    //     state_covariance = P_;
    //     time = timestamp_;
    // }

 /**
    {
        // begin kalman filter core
        S_.fill(0.0);
        // S 偏差的方差阵
        for (int i = 0; i < 17; i++) 
        {  
            Eigen::VectorXd z_diff = Zsig_stack_.col(i);
		    S_ = S_ + model_parameter_.weights_c_(i) * z_diff * z_diff.transpose();//Pz
	    }
        
	    //add measurement noise covariance matrix
	    S_ = S_ + measurement_covariance_stack_;//+R
        // S_inv = (inv(S)+inv(S)')/2, to make symmetric
        S_inverse_ = S_.inverse();
        //        S_inverse_ = (1/2.0) * (S_inverse_ + S_inverse_.transpose());
        // Check if S_inv is positive defined
        if(!isMatrixPositiveDefined(S_inverse_))
        {
            std::cout << "S_inverse_ is not semi-positive definitie, possible error" << std::endl;
        }
        //std::cout << "fines" << std::endl;
        MatrixXd Tc = MatrixXd(TModel::n_x_, total_length_);
        Tc.fill(0.0);
        for (int i = 0; i < 17; i++) 
        {  //2n+1 simga points
            Eigen::VectorXd z_diffi = Zsig_stack_.col(i);
            VectorXd x_diff = Xsig_prediction_.col(i) - x_prediction_;
            double a=x_diff(2);//yaw
            if (a> PI) x_diff(2) = x_diff(2) - 2.*PI;
            if (a<-PI) x_diff(2) = x_diff(2) + 2.*PI;
            double b=x_diff(3);//beta
            if (b> PI) x_diff(3) = x_diff(3) - 2.*PI;
            if (b<-PI) x_diff(3) = x_diff(3) + 2.*PI;
            Tc = Tc + model_parameter_.weights_c_(i) * x_diff * z_diffi.transpose();//Pxz
            //std::cout << "x_diff" << x_diff << std::endl;
        }
        //std::cout << "fines1" << std::endl;
        K_ = Tc *S_inverse_;
        measurement_residual_ = measurement_stack_ - measurement_prediction_stack_;
        // fix angle residual problem
        for(int i=0; i<total_length_; i++)
        {
            if(angle_flag_stack_(i) != 0)
            {
                measurement_residual_(i) = normalizeAngle(measurement_residual_(i));
            }
        }

        x_ = x_prediction_ + K_ * measurement_residual_;
        P_ = P_prediction_ - K_ * S_ * K_.transpose() + 0.0001 * identity_p_;
        // Check if P(k+1|k+1) is positive defined
        if(!isMatrixPositiveDefined(P_))
        {
            std::cout << "P_ is not semi-positive definitie, possible error" << std::endl;
        }
        state = x_;
        state_covariance = P_;//参数输出
        W_=K_;
        //std::cout << "model_parameter_.weights_c_" << model_parameter_.weights_c_ << std::endl;
        //std::cout << "S_=" << S_ << std::endl;
        //std::cout << "P_=" << P_ << std::endl;
        //std::cout << "K_=" << K_ << std::endl;
        time = timestamp_;
    }
    **/
       // template<typename TMeasurement>//测量量结构
    // typename std::enable_if<SensorMeasurementConverter::is_support<TMeasurement, TModel>::value, void>::type
    // AddMeasurement2(TMeasurement& measurement)
    // {
    //     if(!is_adding_measurement_) throw;
    //     if(stack_index_ + 2 > total_length_) throw;/////////////////////////////////////////////////////////////

    //     // stack h vector
    //     typename TMeasurement::MeasurementVector measurement_prediction;
    //     Eigen::MatrixXd Zsig = MatrixXd(2, 17);
    //     SensorMeasurementConverter::getMeasurementPrediction<TMeasurement, TModel>(model_parameter_, Xsig_prediction_, Zsig, measurement_prediction);//具体量测函数里写的
    //     measurement_prediction_stack_.block<2, 1>(stack_index_, 0) = measurement_prediction;
    //     //stack Zsig 
    //     Zsig_stack_.block<2, 17>(stack_index_, 0) = Zsig;//Z_sig 减去z_pred的结果，垒起来  为了计算S

    //     // stack angle flag
    //     typename TMeasurement::MeasurementFlagVector flag;
    //     measurement.getAngleFlag(flag);
    //     angle_flag_stack_.block<2, 1>(stack_index_, 0) = flag;
        
    //     // stack measurement, measurement covariance & angle_flag
    //     double timestamp;
    //     typename TMeasurement::MeasurementVector measurement_vec;
    //     typename TMeasurement::MeasurementMatrix measurement_cov;
    //     measurement.getMeasurement(measurement_vec, measurement_cov, timestamp);
    //     measurement_stack_.block<2, 1>(stack_index_, 0) = measurement_vec;
    //     measurement_covariance_stack_.block<2, 2>(stack_index_, stack_index_) = measurement_cov;
        
    //     stack_index_ += 2;
    // }
//}